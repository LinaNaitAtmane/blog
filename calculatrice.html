<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Calculatrice scientifique & Traceur</title>
<style>
  :root{
    --bg:#ffffff; --panel:#f5f5f5; --accent:#000000; --muted:#666;
    --radius:10px; --gap:12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: Inter, system-ui, Arial, sans-serif;
    background:var(--bg); color:var(--accent); padding:18px;
  }

  .app{max-width:1200px; margin:0 auto; display:grid; grid-template-columns: 420px 1fr; gap:18px; align-items:start;}
  .panel{background:var(--panel); border-radius:var(--radius); padding:14px; box-shadow: 0 6px 20px rgba(0,0,0,0.06);}

  /* left column (controls / calc) */
  .controls {display:flex; flex-direction:column; gap:12px;}
  label{font-size:13px; color:var(--muted); margin-bottom:6px; display:block;}
  input[type="text"], input[type="number"], select, textarea{
    width:100%; padding:10px; border-radius:8px; border:1px solid #ddd; font-size:14px;
    background:white; color:var(--accent);
  }
  .row{display:flex; gap:8px}
  .btn{padding:10px 12px; border-radius:8px; border:1px solid #000; background:#000; color:#fff; cursor:pointer; font-weight:600}
  .btn.secondary{background:transparent; color:var(--accent); border-color:#bbb}
  .small{font-size:13px; color:var(--muted)}

  /* calculator mini */
  .calc-keys{display:grid; grid-template-columns: repeat(4,1fr); gap:8px; margin-top:8px}
  button.key{padding:10px; border-radius:8px; border:1px solid #ccc; background:white; cursor:pointer}
  button.key.op{background:#000; color:#fff; border-color:#000}

  /* right column (graph) */
  .graph-wrap{display:flex; flex-direction:column; gap:8px}
  #canvasWrap{position:relative; background:#fff; border:1px solid #ccc; border-radius:8px; overflow:hidden}
  canvas{width:100%; height:600px; display:block}
  .legend{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .legend .item{display:flex; gap:6px; align-items:center; font-size:13px}
  .swatch{width:18px;height:10px;border-radius:3px}

  /* responsive */
  @media (max-width:980px){ .app{grid-template-columns:1fr; } }
</style>
</head>
<body>
  <h2>Calculatrice scientifique avec traceur</h2>
  <div class="app">
    <aside class="panel controls">
      <div>
        <label>Fonctions (en f(x), sépare par <code>;</code>)</label>
        <input id="fnInput" type="text" value="sin(x); 0.1*x^3 - x" />
        <div class="small">Exemples : <code>sin(x)</code>, <code>2*x+1</code>, <code>exp(-x^2)</code>, <code>x^3 - 3*x</code></div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>X min</label>
          <input id="xmin" type="number" value="-10" step="any">
        </div>
        <div style="flex:1">
          <label>X max</label>
          <input id="xmax" type="number" value="10" step="any">
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Échantillons</label>
          <input id="samples" type="number" value="800" min="100" max="5000">
        </div>
        <div style="flex:1">
          <label>Precision / zoom</label>
          <select id="scaleMode">
            <option value="auto">Auto</option>
            <option value="manual">Manuel</option>
          </select>
        </div>
      </div>

      <div style="display:flex; gap:8px">
        <button class="btn" id="plotBtn">Tracer</button>
        <button class="btn secondary" id="resetView">Reset</button>
        <button class="btn secondary" id="clearBtn">Effacer</button>
      </div>

      <hr>

      <div>
        <label>Calculatrice (saisir expression, variable x possible)</label>
        <input id="calcInput" type="text" placeholder="ex: (2+3)*4 or sin(1.2)" />
        <div class="row" style="margin-top:8px">
          <button class="btn" id="calcEval">Calculer</button>
          <button class="btn secondary" id="ansBtn">ANS</button>
        </div>
        <div id="calcResult" class="small" style="margin-top:8px">Résultat : <span id="resVal">—</span></div>

        <div class="calc-keys" style="margin-top:10px">
          <button class="key" data-insert="7">7</button><button class="key" data-insert="8">8</button><button class="key" data-insert="9">9</button><button class="key op" data-insert="/">/</button>
          <button class="key" data-insert="4">4</button><button class="key" data-insert="5">5</button><button class="key" data-insert="6">6</button><button class="key op" data-insert="*">*</button>
          <button class="key" data-insert="1">1</button><button class="key" data-insert="2">2</button><button class="key" data-insert="3">3</button><button class="key op" data-insert="-">-</button>
          <button class="key" data-insert="0">0</button><button class="key" data-insert=".">.</button><button class="key" data-insert="^">^</button><button class="key op" data-insert="+">+</button>
        </div>
      </div>

      <hr>
      <div>
        <div class="small">Aide : fonctions disponibles — <code>sin, cos, tan, asin, acos, atan, exp, ln, log, sqrt, abs, floor, ceil</code></div>
        <div class="small" style="margin-top:6px">Zoom : molette ; Pan : cliquer-glisser ; Multi-fonctions: séparer avec <code>;</code>.</div>
      </div>
    </aside>

    <main class="panel graph-wrap">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px">
        <div>
          <strong>Graphique</strong>
        </div>
        <div class="legend" id="legend"></div>
      </div>

      <div id="canvasWrap" >
        <canvas id="graphCanvas" width="1000" height="600"></canvas>
      </div>
      <div style="display:flex; gap:8px; margin-top:8px">
        <div class="small">Coordonnées : <span id="coord">—</span></div>
        <div style="flex:1"></div>
        <div class="small">Échelle: <span id="scaleInfo">1</span></div>
      </div>
    </main>
  </div>

<script>
/* -----------------------
   Petit parseur/sécurisé d'expressions
   Supporte variable x et fonctions listées ci-dessous.
   ----------------------- */
const FUNC_MAP = {
  'sin': Math.sin, 'cos': Math.cos, 'tan': Math.tan,
  'asin': Math.asin, 'acos': Math.acos, 'atan': Math.atan,
  'exp': Math.exp, 'ln': Math.log, 'log': Math.log10 || ((v)=>Math.log(v)/Math.LN10),
  'sqrt': Math.sqrt, 'abs': Math.abs, 'floor': Math.floor, 'ceil': Math.ceil,
  'pow': Math.pow
};

function tokenize(s){
  // tokens: numbers, identifiers, operators, parentheses, comma
  const re = /\s*([0-9]*\.?[0-9]+|[A-Za-z_][A-Za-z0-9_]*|\^|\+|\-|\*|\/|\(|\)|,)\s*/g;
  const toks = [];
  let m;
  while((m = re.exec(s)) !== null) toks.push(m[1]);
  return toks;
}

function parseExpressionToAST(s){
  const tokens = tokenize(s);
  let i = 0;
  function peek(){ return tokens[i]; }
  function get(){ return tokens[i++]; }

  function parsePrimary(){
    let t = peek();
    if(t === '('){ get(); const e = parseExpression(); if(get() !== ')') throw 'Expected )'; return e; }
    if(/^[0-9]*\.?[0-9]+$/.test(t)){ get(); return {type:'num', value: parseFloat(t)}; }
    if(/^[A-Za-z_][A-Za-z0-9_]*$/.test(t)){
      const id = get();
      if(peek() === '('){
        get(); // consume '('
        const args = [];
        if(peek() !== ')'){
          while(true){ args.push(parseExpression()); if(peek() === ')') break; if(get() !== ',') throw 'Expected ,'; }
        }
        if(get() !== ')') throw 'Expected )';
        return {type:'call', name:id, args};
      } else {
        return {type:'var', name:id};
      }
    }
    throw 'Unexpected token ' + t;
  }

  function parsePow(){
    let left = parsePrimary();
    while(peek() === '^'){ get(); const right = parsePow(); left = {type:'op', op:'^', a:left, b:right}; }
    return left;
  }

  function parseTerm(){
    let left = parsePow();
    while(peek() === '*' || peek() === '/'){
      const op = get(); const right = parsePow();
      left = {type:'op', op, a:left, b:right};
    }
    return left;
  }

  function parseExpression(){
    let left = parseTerm();
    while(peek() === '+' || peek() === '-'){
      const op = get(); const right = parseTerm();
      left = {type:'op', op, a:left, b:right};
    }
    return left;
  }

  const ast = parseExpression();
  if(i < tokens.length) throw 'Unexpected token '+peek();
  return ast;
}

function evalAST(ast, env){
  if(ast.type === 'num') return ast.value;
  if(ast.type === 'var') return (env && ast.name in env) ? env[ast.name] : (ast.name === 'pi' ? Math.PI : (ast.name === 'e' ? Math.E : NaN));
  if(ast.type === 'call'){
    const fname = ast.name.toLowerCase();
    const f = FUNC_MAP[fname];
    const args = ast.args.map(a=>evalAST(a, env));
    if(fname === 'log'){ // allow log(x, base)
      if(args.length === 2) return Math.log(args[0]) / Math.log(args[1]);
      return Math.log10 ? Math.log10(args[0]) : Math.log(args[0])/Math.LN10;
    }
    if(f) return f.apply(null, args);
    if(fname === 'pow') return Math.pow(args[0], args[1]);
    throw 'Fonction inconnue '+ast.name;
  }
  if(ast.type === 'op'){
    const a = evalAST(ast.a, env), b = evalAST(ast.b, env);
    switch(ast.op){
      case '+': return a+b;
      case '-': return a-b;
      case '*': return a*b;
      case '/': return a/b;
      case '^': return Math.pow(a,b);
    }
  }
  throw 'AST eval error';
}

function compileExpression(s){
  const ast = parseExpressionToAST(s);
  return function(x){
    return evalAST(ast, {x});
  }
}

/* -----------------------
   Gestion du graphe (canvas)
   ----------------------- */
const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = canvas.clientWidth;
let height = canvas.height = canvas.clientHeight;

window.addEventListener('resize', ()=>{ width = canvas.width = canvas.clientWidth; height = canvas.height = canvas.clientHeight; redraw(); });

let view = { xmin: -10, xmax: 10, ymin: -6, ymax: 6 }; // view box (math coords)
let dragging = false, lastMouse = null;
let scaleDisplay = 1;

function mapX(x){ return (x - view.xmin) / (view.xmax - view.xmin) * width; }
function mapY(y){ return height - (y - view.ymin) / (view.ymax - view.ymin) * height; }
function invMapX(px){ return view.xmin + px/width * (view.xmax - view.xmin); }
function invMapY(py){ return view.ymin + (height-py)/height * (view.ymax - view.ymin); }

function drawGrid(){
  ctx.clearRect(0,0,width,height);
  // background
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,width,height);

  // compute nice grid step
  const xRange = view.xmax - view.xmin;
  const yRange = view.ymax - view.ymin;
  // nice step function
  function niceStep(range){
    const raw = range/10;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const r = raw / pow;
    let step;
    if(r < 1.5) step = 1*pow;
    else if(r < 3.5) step = 2*pow;
    else if(r < 7.5) step = 5*pow;
    else step = 10*pow;
    return step;
  }
  const xStep = niceStep(xRange);
  const yStep = niceStep(yRange);

  // vertical grid lines
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  for(let gx = Math.ceil(view.xmin / xStep) * xStep; gx <= view.xmax; gx += xStep){
    const px = mapX(gx);
    ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,height); ctx.stroke();
  }
  // horizontal grid
  for(let gy = Math.ceil(view.ymin / yStep) * yStep; gy <= view.ymax; gy += yStep){
    const py = mapY(gy);
    ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(width,py); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.2;
  // x axis
  if(view.ymin < 0 && view.ymax > 0){
    const y0 = mapY(0);
    ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(width,y0); ctx.stroke();
  }
  // y axis
  if(view.xmin < 0 && view.xmax > 0){
    const x0 = mapX(0);
    ctx.beginPath(); ctx.moveTo(x0,0); ctx.lineTo(x0,height); ctx.stroke();
  }
}

function drawFunctions(compiledFns, colors){
  const samples = Math.min(Math.max(parseInt(document.getElementById('samples').value)||800, 100), 5000);
  const xmin = view.xmin, xmax = view.xmax;
  for(let k=0;k<compiledFns.length;k++){
    const f = compiledFns[k]; const color = colors[k];
    ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
    let started = false;
    for(let i=0;i<=samples;i++){
      const t = i / samples;
      const x = xmin + t*(xmax-xmin);
      let y;
      try{ y = f(x); }
      catch(e){ y = NaN; }
      const px = mapX(x), py = mapY(y);
      if(!isFinite(y)){ started = false; continue; }
      if(!started){ ctx.moveTo(px,py); started = true; } else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
}

function redraw(compiledFns, colors){
  drawGrid();
  if(compiledFns && compiledFns.length) drawFunctions(compiledFns, colors);
}

/* -----------------------
   UI wiring
   ----------------------- */
function parseFunctionsFromInput(){
  const raw = document.getElementById('fnInput').value.trim();
  if(!raw) return [];
  const parts = raw.split(';').map(s=>s.trim()).filter(s=>s.length>0);
  const compiled = [];
  for(const p of parts){
    try{
      const astFn = compileExpression(p);
      compiled.push(astFn);
    } catch(e){
      console.error('Erreur compilation', p, e);
      // try to give feedback
      alert('Erreur dans la fonction : '+p + '\\n' + e);
      return null;
    }
  }
  return compiled;
}

function autoAdjustY(compiledFns){
  // estimate y-range by sampling
  const xmin = view.xmin, xmax = view.xmax;
  let ymin = Infinity, ymax = -Infinity;
  const samples = 400;
  for(const f of compiledFns){
    for(let i=0;i<=samples;i++){
      const x = xmin + (xmax-xmin)*(i/samples);
      try{
        const y = f(x);
        if(isFinite(y)){ ymin = Math.min(ymin,y); ymax = Math.max(ymax,y); }
      } catch(e){}
    }
  }
  if(ymin === Infinity) { ymin = -10; ymax = 10; }
  if(ymin === ymax){ ymin -= 1; ymax += 1; }
  view.ymin = ymin - 0.08*(ymax-ymin);
  view.ymax = ymax + 0.08*(ymax-ymin);
  document.getElementById('scaleInfo').textContent = Math.round((view.xmax-view.xmin)*100)/100;
}

function generateColors(n){
  const palette = ['#e60000','#0074d9','#2ecc40','#ff851b','#b10dc9','#ffdc00','#001f3f','#7f8c8d'];
  const out = [];
  for(let i=0;i<n;i++) out.push(palette[i % palette.length]);
  return out;
}

document.getElementById('plotBtn').addEventListener('click', ()=>{
  const compiled = parseFunctionsFromInput();
  if(compiled === null) return;
  if(compiled.length === 0){ redraw([],[]); return; }
  // compile wrapper functions (handle x)
  const compiledWrap = compiled;
  if(document.getElementById('scaleMode').value === 'auto') autoAdjustY(compiledWrap);
  const colors = generateColors(compiledWrap.length);
  // update legend
  const legend = document.getElementById('legend'); legend.innerHTML = '';
  const parts = document.getElementById('fnInput').value.split(';').map(s=>s.trim()).filter(Boolean);
  for(let i=0;i<parts.length;i++){
    const it = document.createElement('div'); it.className='item';
    const sw = document.createElement('div'); sw.className='swatch'; sw.style.background = colors[i];
    it.appendChild(sw);
    const txt = document.createElement('div'); txt.textContent = parts[i]; it.appendChild(txt);
    legend.appendChild(it);
  }
  redraw(compiledWrap, colors);
});

// reset and clear
document.getElementById('resetView').addEventListener('click', ()=>{ view = { xmin: -10, xmax: 10, ymin: -6, ymax: 6 }; redraw(parseFunctionsFromInput(), generateColors(5)); });
document.getElementById('clearBtn').addEventListener('click', ()=>{ document.getElementById('fnInput').value=''; redraw([],[]); document.getElementById('legend').innerHTML=''; });

/* Interactions: pan & zoom & coords */
canvas.addEventListener('mousedown', (e)=>{
  dragging = true; lastMouse = {x:e.clientX, y:e.clientY};
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', ()=>{ dragging = false; canvas.style.cursor='default'; lastMouse=null; });
window.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
  document.getElementById('coord').textContent = '('+invMapX(cx).toFixed(3)+', '+invMapY(cy).toFixed(3)+')';
  if(dragging && lastMouse){
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    // convert to math units
    const dxUnits = -dx/width * (view.xmax - view.xmin);
    const dyUnits = dy/height * (view.ymax - view.ymin);
    view.xmin += dxUnits; view.xmax += dxUnits;
    view.ymin += dyUnits; view.ymax += dyUnits;
    lastMouse = {x:e.clientX, y:e.clientY};
    const compiled = parseFunctionsFromInput(); redraw(compiled || [], generateColors(5));
  }
});

canvas.addEventListener('wheel', (ev)=>{
  ev.preventDefault();
  const delta = ev.deltaY;
  // zoom center around mouse
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
  const cx = invMapX(mx), cy = invMapY(my);
  const zoomFactor = Math.exp(delta * 0.0012); // >1 zoom out
  const newWidth = (view.xmax - view.xmin) * zoomFactor;
  const newHeight = (view.ymax - view.ymin) * zoomFactor;
  view.xmin = cx - (cx - view.xmin) * zoomFactor;
  view.xmax = view.xmin + newWidth;
  view.ymin = cy - (cy - view.ymin) * zoomFactor;
  view.ymax = view.ymin + newHeight;
  scaleDisplay = Math.round((view.xmax-view.xmin)*100)/100;
  document.getElementById('scaleInfo').textContent = scaleDisplay;
  const compiled = parseFunctionsFromInput(); redraw(compiled || [], generateColors(5));
}, { passive:false });

/* keyboard & calculator integration */
let lastAns = 0;
document.getElementById('calcEval').addEventListener('click', ()=>{ const s = document.getElementById('calcInput').value.trim(); if(!s) return; try{ const fn = compileExpression(s); const v = fn( (typeof window.x !== 'undefined') ? window.x : 0 ); lastAns = v; document.getElementById('resVal').textContent = v; }catch(e){ document.getElementById('resVal').textContent = 'Erreur'; }});
document.getElementById('ansBtn').addEventListener('click', ()=>{ document.getElementById('calcInput').value += String(lastAns); });

document.querySelectorAll('button.key').forEach(b=>{
  b.addEventListener('click', ()=>{ document.getElementById('calcInput').value += b.dataset.insert; });
});

document.getElementById('fnInput').addEventListener('keydown', (e)=>{ if(e.key === 'Enter') document.getElementById('plotBtn').click(); });
document.getElementById('calcInput').addEventListener('keydown', (e)=>{ if(e.key === 'Enter') document.getElementById('calcEval').click(); });

/* initial draw */
redraw([],[]);
</script>
</body>
</html>
